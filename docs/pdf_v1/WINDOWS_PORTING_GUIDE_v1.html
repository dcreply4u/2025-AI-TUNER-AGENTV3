<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WINDOWS_PORTING_GUIDE</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    # Windows Porting Guide<br>
<br>
## Overview<br>
<br>
This guide explains how the TelemetryIQ codebase has been ported to run on Windows with affordable hardware adapters.<br>
<br>
## Porting Strategy<br>
<br>
### 1. Python is Cross-Platform<br>
<br>
**Good News:** Most of the code already works on Windows! Python is cross-platform, so:<br>
- ✅ All Python code runs on Windows<br>
- ✅ Most libraries work on Windows<br>
- ✅ Path handling uses `pathlib` (cross-platform)<br>
<br>
### 2. Platform-Specific Code<br>
<br>
The codebase uses platform detection to handle differences:<br>
<br>
```python<br>
import platform<br>
<br>
if platform.system() == "Windows":<br>
    # Windows-specific code<br>
elif platform.system() == "Linux":<br>
    # Linux-specific code<br>
```<br>
<br>
### 3. Hardware Interface Abstraction<br>
<br>
Instead of direct GPIO access (Linux-only), Windows uses:<br>
- **USB GPIO Adapters** (FTDI, CH340)<br>
- **Arduino via Serial** (USB connection)<br>
- **USB-CAN Adapters** (for ECU communication)<br>
- **OBD-II Adapters** (for standard vehicles)<br>
<br>
## Changes Made<br>
<br>
### 1. Hardware Platform Detection<br>
<br>
**File:** `core/hardware_platform.py`<br>
<br>
Added Windows detection:<br>
```python<br>
if platform.system() == "Windows":<br>
    return HardwareDetector._windows_config()<br>
```<br>
<br>
Windows config:<br>
- No native GPIO (uses USB adapters)<br>
- No native CAN (uses USB-CAN adapters)<br>
- USB serial for Arduino communication<br>
<br>
### 2. Windows Hardware Adapter<br>
<br>
**File:** `interfaces/windows_hardware_adapter.py` (NEW)<br>
<br>
Provides Windows-compatible hardware interfaces:<br>
- Arduino detection and communication<br>
- USB GPIO adapter support<br>
- Serial port management<br>
- USB device detection<br>
<br>
### 3. Digital Sensor Interface<br>
<br>
**File:** `interfaces/digital_sensor.py`<br>
<br>
Updated to support Windows:<br>
```python<br>
if platform.system() == "Windows" and WINDOWS_ADAPTER:<br>
    self._init_windows_gpio()<br>
```<br>
<br>
### 4. Path Handling<br>
<br>
Already cross-platform using `pathlib.Path`:<br>
```python<br>
from pathlib import Path<br>
config_file = Path("config") / "settings.json"  # Works on Windows and Linux<br>
```<br>
<br>
## What Works on Windows<br>
<br>
### ✅ Already Works<br>
<br>
1. **Core Application**<br>
   - All Python code<br>
   - GUI (PySide6 works on Windows)<br>
   - Data processing<br>
   - AI features<br>
   - Configuration management<br>
<br>
2. **Communication**<br>
   - OBD-II (via python-OBD)<br>
   - Serial communication (pyserial)<br>
   - USB devices (pyusb)<br>
   - Network communication<br>
<br>
3. **File Operations**<br>
   - All file I/O<br>
   - Configuration files<br>
   - Logging<br>
   - Data export/import<br>
<br>
### ⚠️ Needs Adapters<br>
<br>
1. **GPIO** → USB GPIO adapter or Arduino<br>
2. **CAN Bus** → USB-CAN adapter<br>
3. **Analog Sensors** → USB ADC board or Arduino<br>
<br>
## Installation Process<br>
<br>
### Option 1: Automated Installer<br>
<br>
1. Run `TelemetryIQ-Setup.exe`<br>
2. Installer will:<br>
   - Install Python (if needed)<br>
   - Install dependencies<br>
   - Install drivers<br>
   - Create shortcuts<br>
<br>
### Option 2: Manual Setup<br>
<br>
1. **Install Python 3.11+**<br>
   - Download from python.org<br>
   - Check "Add Python to PATH"<br>
<br>
2. **Run Setup Script**<br>
   ```batch<br>
   setup_windows.bat<br>
   ```<br>
<br>
3. **Install Drivers** (if using USB adapters)<br>
   - FTDI: Run `drivers\FTDI\CDM21228_Setup.exe`<br>
   - CH340: Run `drivers\CH340\CH341SER.EXE`<br>
<br>
4. **Connect Hardware**<br>
   - Plug in Arduino/USB adapters<br>
   - Windows should detect them<br>
<br>
5. **Run Application**<br>
   ```batch<br>
   python demo.py<br>
   ```<br>
<br>
## Hardware Setup<br>
<br>
### Arduino Setup<br>
<br>
1. **Upload Firmware**<br>
   - Use Arduino IDE<br>
   - Upload `hardware/arduino_gpio_breakout.ino`<br>
   - Note the COM port (e.g., COM3)<br>
<br>
2. **Configure in App**<br>
   - Go to Settings → Hardware Interfaces<br>
   - Select Arduino<br>
   - Choose COM port<br>
   - Test connection<br>
<br>
### USB-CAN Adapter Setup<br>
<br>
1. **Install Driver**<br>
   - Driver depends on adapter model<br>
   - Usually provided by manufacturer<br>
<br>
2. **Configure in App**<br>
   - Go to Settings → CAN Bus<br>
   - Select USB-CAN adapter<br>
   - Set bitrate (usually 500000)<br>
<br>
### OBD-II Setup<br>
<br>
1. **Connect Adapter**<br>
   - Plug ELM327 adapter into OBD-II port<br>
   - Connect via Bluetooth or USB<br>
<br>
2. **Configure in App**<br>
   - Go to Settings → OBD-II<br>
   - Select adapter type<br>
   - Auto-connect should work<br>
<br>
## Testing on Windows<br>
<br>
### Test Hardware Detection<br>
<br>
```python<br>
from interfaces.windows_hardware_adapter import WindowsHardwareAdapter<br>
<br>
adapter = WindowsHardwareAdapter()<br>
devices = adapter.detect_adapters()<br>
for device in devices:<br>
    print(f"Found: {device.name} on {device.port}")<br>
```<br>
<br>
### Test Arduino Connection<br>
<br>
```python<br>
from interfaces.windows_hardware_adapter import WindowsHardwareAdapter<br>
<br>
adapter = WindowsHardwareAdapter()<br>
ser = adapter.connect_arduino("COM3")<br>
if ser:<br>
    value = adapter.read_arduino_pin("COM3", 13)<br>
    print(f"Pin 13: {value}")<br>
```<br>
<br>
## Troubleshooting<br>
<br>
### Python Not Found<br>
<br>
**Problem:** `python` command not recognized<br>
<br>
**Solution:**<br>
1. Reinstall Python<br>
2. Check "Add Python to PATH"<br>
3. Or use full path: `C:\Python311\python.exe`<br>
<br>
### Driver Issues<br>
<br>
**Problem:** USB device not recognized<br>
<br>
**Solution:**<br>
1. Install correct driver<br>
2. Check Device Manager<br>
3. Try different USB port<br>
4. Update Windows<br>
<br>
### COM Port Issues<br>
<br>
**Problem:** Can't connect to Arduino<br>
<br>
**Solution:**<br>
1. Check COM port in Device Manager<br>
2. Make sure no other program is using it<br>
3. Try different baud rate<br>
4. Check Arduino firmware is uploaded<br>
<br>
### Permission Errors<br>
<br>
**Problem:** Can't access USB devices<br>
<br>
**Solution:**<br>
1. Run as Administrator<br>
2. Check USB permissions<br>
3. Install drivers as Admin<br>
<br>
## Performance Considerations<br>
<br>
### USB Latency<br>
<br>
- USB communication has higher latency than native GPIO<br>
- Batch sensor readings when possible<br>
- Use async I/O for better performance<br>
<br>
### Serial Communication<br>
<br>
- Arduino serial is slower than native GPIO<br>
- Use higher baud rates (115200+)<br>
- Minimize command frequency<br>
<br>
### Windows-Specific Optimizations<br>
<br>
- Use Windows-specific serial libraries if available<br>
- Consider USB HID for faster communication<br>
- Cache frequently accessed data<br>
<br>
## Building the Installer<br>
<br>
### Requirements<br>
<br>
- Inno Setup 6+ (free)<br>
- Python runtime (optional - can bundle)<br>
- Driver files<br>
<br>
### Build Steps<br>
<br>
1. **Prepare Files**<br>
   - Ensure all code is in `AI-TUNER-AGENT/`<br>
   - Place drivers in `drivers/windows/`<br>
   - Create `LICENSE.txt`<br>
<br>
2. **Run Inno Setup**<br>
   - Open `installer/windows_installer.iss`<br>
   - Click "Build" → "Compile"<br>
   - Installer will be in `dist/`<br>
<br>
3. **Test Installer**<br>
   - Run on clean Windows machine<br>
   - Test all features<br>
   - Verify drivers install correctly<br>
<br>
## Distribution<br>
<br>
### Installer Package<br>
<br>
Include:<br>
- `TelemetryIQ-Setup.exe` (main installer)<br>
- `README-Windows.txt` (setup instructions)<br>
- Hardware compatibility list<br>
- Driver download links<br>
<br>
### Optional: Portable Version<br>
<br>
Create portable version:<br>
- No installer needed<br>
- Python bundled<br>
- Run from USB drive<br>
- Good for demos<br>
<br>
## Next Steps<br>
<br>
1. **Test on Windows 10/11**<br>
2. **Test with various hardware**<br>
3. **Create user documentation**<br>
4. **Build installer package**<br>
5. **Test installation process**<br>
<br>
## Summary<br>
<br>
The porting is straightforward because:<br>
- ✅ Python is cross-platform<br>
- ✅ Most libraries work on Windows<br>
- ✅ Hardware abstraction layer handles differences<br>
- ✅ USB adapters provide same functionality<br>
<br>
The main work is:<br>
- Hardware adapter implementation (DONE)<br>
- Driver management (DONE)<br>
- Installer creation (DONE)<br>
- Testing and documentation (IN PROGRESS)<br>
<br>
<br>
<br>
<br>
<br>

</body>
</html>